#!/usr/local/bin/perl -w
#
# Copyright (C) 1998-2000  Internet Software Consortium.
# 
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
# ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
# CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
# DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
# PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.

# $Id: update_copyrights,v 1.14.2.2 2000/07/03 17:48:32 gson Exp $

require 5.002;

# Map copyright owners to the files containing copyright messages.
# The first line of the copyright message is not in the file;
# it is constructed by this script.  

my %owner2filename = (
    "" => "util/COPYRIGHT",
    "NAI" => "util/COPYRIGHT.NAI",
    "BSDI" => "util/COPYRIGHT.BSDI",
    "BRIEF" => "util/COPYRIGHT.BRIEF",
    "PORTION" => "util/COPYRIGHT.PORTION",
);

# Map each copyright owner name to a reference to an array containing
# the lines of the copyright message.

my %owner2text = ();

foreach $owner (keys %owner2filename) {
    my $f = $owner2filename{$owner};
    open(COPYRIGHT, "<$f") || die "can't open $f: $!";
    @copyright_text = <COPYRIGHT>;
    close(COPYRIGHT);
    $owner2text{$owner} = [ @copyright_text ];
}

while (<>) {
    ($file, $typeandowner, $years_list) = split(/\s+/);
    @years = split(/,/, $years_list);

    if ( ! -f $file ) {
	print "$file: missing\n";
	next;
    }

    my ($type, $owner) = split(/\./, $typeandowner);
    $owner = "" if !defined $owner;

    $textp = $owner2text{$owner};
    if (!defined $textp) {
	print "$file: unknown copyright owner $owner\n";
	next;
    }
	
    next if $type eq "X";

    $before_copyright = "";
    $c_comment = 0;
    $shell_comment = 0;
    $m4_comment = 0;
    $html_comment = 0;
    $zone_comment = 0;
    $man_comment = 0;
    $start_comment = "";
    $end_comment = "";
    $first = "";
    if ($type =~ /^(C|YACC|CONF-C)/) {
	$c_comment = 1;
        $start_comment = "/*\n";
	$prefix = " * ";
        $end_comment = " */\n";
    } elsif ($type =~ /^(SH|PERL|MAKE|CONF-SH)/) {
	$shell_comment = 1;
	$prefix = "# ";
    } elsif ($type eq "ZONE") {
	$zone_comment = 1;
	$prefix = "; ";
    } elsif ($type eq "MAN") {
	$man_comment = 1;
	$prefix = ".\\\" ";
    } elsif ($type eq "M4") {
	$m4_comment = 1;
	$prefix = "dnl ";
    } elsif ($type eq "HTML") {
	$html_comment = 1;
        $start_comment = "<!--\n";
	$prefix = " - ";
        $end_comment = "-->\n";
    } elsif ($type eq "TXT") {
        $prefix = "";
    } else {
	print "$file: type '$type' not supported yet; skipping\n";
	next;
    }

    ($nonspaceprefix = $prefix) =~ s/\s+$//;

    open(SOURCE, "<$file") || die "can't open $file: $!";
    $_ = <SOURCE>;
    if ($type eq "YACC") {
	unless ($_ eq "%{\n") {
          print "$file: unexpected yacc file start (expected \"%{\\n\")\n";
          close(SOURCE);
          next;
        }
	$before_copyright = "$_";
        $_ = <SOURCE>;
    }
    if ($c_comment && /^\/\*/) {
	$_ = <SOURCE>;
	if ($_ !~ /[Cc]opyright/) {
	    print "$file: non-copyright comment\n";
	    close(SOURCE);
	    next;
	}
	if ($_ !~ /\*\//) {
	    while (<SOURCE>) {
		if ($_ =~ /\*\//) {
		    last;
		}
	    }
	}
    } elsif ($shell_comment) {
	if (/^\#\!/) {
	    $before_copyright = "$_#\n";
	    $_ = <SOURCE>;
            $_ = <SOURCE> if $_ eq "#\n";
	}
	if (/^\#/) {
	    if ($_ !~ /[Cc]opyright/) {
		print "$file: non-copyright comment\n";
		close(SOURCE);
		next;
	    }
	    while (<SOURCE>) {
		if ($_ !~ /^\#/) {
		    $first = $_;
		    last;
		}
	    }
	} else {
	    $first = $_;
	}
    } elsif (($m4_comment || $zone_comment || $man_comment) &&
             /^\Q$nonspaceprefix\E/) {

        while (/^\Q$nonspaceprefix\E\s*$/) {
            $_ = <SOURCE>;
        }

	if ($_ !~ /[Cc]opyright/) {
	    print "$file: non-copyright comment\n";
	    close(SOURCE);
	    next;
	}
	while (<SOURCE>) {
	    if ($_ !~ /^\Q$nonspaceprefix\E/) {
		$first = $_;
		last;
	    }
	}
    } elsif ($html_comment) {
        if (/^<!DOCTYPE/) {
          $before_copyright = $_;
          $_ = <SOURCE>;
        }
        if (/^<!/) {
          $_ = <SOURCE> if $_ eq "<!--\n";
          if ($_ !~ /[Cc]opyright/) {
	    print "$file: non-copyright comment\n";
	    close(SOURCE);
	    next;
          }
          while (defined($_)) {
              last if s/.*-->//;
              $_ = <SOURCE>;
          }
          print "$file: unterminated comment\n" unless defined($_);
          if ($_ ne "\n") {
              $first = $_;
          } else {
              $first = <SOURCE>;
          }
        } else {
          $first = $_;
        }
    } elsif ($type eq "TXT") {
        if ($_ =~ /[Cc]opyright/) {
            $/ = "";            # paragraph at a time
            while (<SOURCE>) {
                # Not very maintainable, but suitable enough for now.
                last unless
                  /See COPYRIGHT in the source root/ ||
                  /Permission to use, copy, modify, and distribute / ||
                  /THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET /;
            }
            $/ = "\n";
        } 
        $first = $_;
    } else {
	$first = $_;
    }

    $first = "" if ! defined($first);

    open(TARGET, ">$file.new") || die "can't open $file.new: $!";
    if ($before_copyright ne "") {
	print TARGET $before_copyright;
    }
    if ($start_comment) {
	print TARGET $start_comment;
    }

    $years = "";    
    $last_year = 0;
    $anchor_year = 0;
    foreach $year (@years) {
        if ($last_year != 0 && $year == $last_year + 1) {
            if ($year > $anchor_year + 1) {
                substr($years, $anchor_end) = "-$year";
            } else {
                $years .= ", $year";
            }
        } else {
            $years .= $last_year == 0 ? "$year" : ", $year";
            if ($anchor_year != 0) {
                print "$file: noncontiguous year: $year != $last_year + 1\n";
            }
            $anchor_year = $year;
            $anchor_end = length($years);
        }

        $last_year = $year;
    }

    ($firstline, @otherlines) = @$textp;

    $firstline =~ s/\@YEARS\@/$years/;

    print TARGET "$prefix$firstline";
    
    foreach $_ (@otherlines) {
	print TARGET "${prefix}$_";
    }
    if ($end_comment) {
	print TARGET $end_comment;
    }
    if ($first eq "") {
	$first = <SOURCE>;
    }
    if (defined($first)) {
        print TARGET "\n";

        undef $/;
        $_ = <SOURCE>;
        $/ = "\n";

        my $pat = '\$(Id|Revision):.*\$';
        my ($start, $end);
        if ($start_comment ne "") {
            ($start = $start_comment) =~ s/\s*\n/ /;
            ($end = $end_comment) =~ s/^\s*(.*)\n/ $1\n/;
        } elsif ($prefix ne "") {
            ($start = $prefix) =~ s/\s*\n//;
            $end = "\n";
        } else {
            $start = "";
            $end = "\n";
        }

        if ($first !~ /$pat/ && $_ !~ /$pat/) {
            print TARGET "$start\$";
            print TARGET "Id: ";
            print TARGET "\$$end\n";
        }

        print TARGET $first if $first !~ /^\s*$/;
        print TARGET $_;
    }
    close(TARGET);
    close(SOURCE);
    $mode = (stat $file)[2]&511;
    chmod $mode, "$file.new";

    if (system("cmp -s $file.new $file") == 0) {
        unlink("$file.new");
    } else {
        rename("$file", "$file.bak") || die "rename($file, $file.bak): $!";
        rename("$file.new", "$file") || die "rename($file.new, $file): $!";
    }
}
